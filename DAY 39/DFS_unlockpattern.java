/*A device is secured with a digital screen, 
The digital screen is made up of a 3*3 grid like below:
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 7 | 8 | 9 |

The code is generated by connecting the keys in a valid way using the grid.

Rules to create the valid codes are as follows:
	- Each code must consist of atleast m keys and atmost n keys.
	- All the keys must be distinct.
	- If the line connecting two consecutive keys 'A','B' in the code passes 
	  through any other key C, then 'C' must have already connected priorly, 
	  as a part of the code. No jumps through a key which is not part of 
	  the code are allowed.
	- The order of keys used matters.
 
You will be given two integers m and n, where 1 ≤ m ≤ n ≤ 9, 
Your task is to count the total number of valid codes can be created to 
sefeguard the device, which consist of minimum of m keys and maximum n keys. 

Examples of valid and invalid codes:
	Invalid code: 1 - 2 - 7 - 9
	Line 7 - 9, passes through key 8 which has not been part of the code.
	i.e., 1 - 2 - 7 - 9 - 8 is also an invalid code.

	Invalid code: 1 - 8 - 3 - 7
	Line 3 - 7 passes through key 5 which has not been part of the code.

	Valid code: 5 - 7 - 4 - 6 - 9   
	Line 4 - 6 is valid because it passes through key 5, which has been part 
	of the code

	Valid code: 4 - 5 - 6 - 3 - 7 - 2
	Line 3 - 7 is valid because it passes through key 5, which has been part 
	of the code

Input Format:
-------------
Two space separated integers M and N.

Output Format:
--------------
Print an integer, number of valid codes created using the digital screen.


Sample Input-1:
---------------
1 1

Sample Output-1:
----------------
9


Sample Input-2:
---------------
1 2

Sample Output-2:
----------------
65
*/
import java.util.*;
import java.lang.*;
public class ma{
    public static void main(String[] args)
    {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int m=sc.nextInt();
        System.out.println(pattern(n,m));
    }
    public static int pattern(int n,int m)
    {
        int a[][]=new int[10][10];
        a[1][3]=a[3][1]=2;
        a[1][7]=a[7][1]=4;
        a[7][9]=a[9][7]=8;
        a[9][3]=a[3][9]=6;
        a[1][9]=a[9][1]=5;
        a[7][3]=a[3][7]=5;
        a[2][8]=a[8][2]=5;
        a[4][6]=a[6][4]=5;
        int visited[]=new int[10];
        int ans=0;
        for(int i=n;i<=m;i++)
        {
            ans=ans+dfs(a,visited,1,i-1)*4;
            ans=ans+dfs(a,visited,2,i-1)*4;
            ans=ans+dfs(a,visited,5,i-1);
        }
        return ans;
    }
    public static int dfs(int a[][],int visited[],int n,int rem)
    {
        if(rem<0)
        {
            return 0;
        }
        if(rem==0)
        {
            return 1;
        }
        visited[n]=1;
        int ans=0;
        for(int i=1;i<=9;i++)
        {
            if(visited[i]==0&&(a[n][i]==0||visited[a[n][i]]==1))
            {
                ans=ans+dfs(a,visited,i,rem-1);
            }
        }
        visited[n]=0;
        return ans;
    }
}
